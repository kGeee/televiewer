# Phase 05, Plan 02: Read Path Migration

---

## Plan Metadata

```yaml
phase: 5
plan: 05-02
wave: 2
depends_on: ['05-01']
autonomous: true
files_modified:
  - src/routes/sessions/[id]/+page.server.ts
  - src/routes/api/sessions/[id]/gps/+server.ts
  - src/routes/api/sessions/[id]/path/+server.ts
  - src/routes/api/sessions/[id]/merge/+server.ts
  - src/lib/server/telemetry/parquet.ts
estimated_context: 30%
```

## must_haves

```yaml
truths:
  - 'All telemetry read paths consume Parquet files instead of PostgreSQL arrays'
  - 'Session detail page loads telemetry from Parquet with equivalent performance'
  - 'GPS, path, and merge APIs read from Parquet files'
  - 'Fallback to empty telemetry if Parquet file is missing (backward compatibility)'

artifacts:
  - path: 'src/lib/server/telemetry/parquet.ts'
    provides: 'Extended with read functions for all query patterns'
    min_lines: 250
  - path: 'src/routes/sessions/[id]/+page.server.ts'
    provides: 'Modified to read telemetry from Parquet'
    min_lines: 100
  - path: 'src/routes/api/sessions/[id]/gps/+server.ts'
    provides: 'Modified to read GPS data from Parquet'
    min_lines: 50
  - path: 'src/routes/api/sessions/[id]/path/+server.ts'
    provides: 'Modified to read path data from Parquet'
    min_lines: 50
  - path: 'src/routes/api/sessions/[id]/merge/+server.ts'
    provides: 'Modified to read primary telemetry from Parquet'
    min_lines: 100

key_links:
  - from: 'src/routes/sessions/[id]/+page.server.ts:load()'
    to: 'src/lib/server/telemetry/parquet.ts:readSessionTelemetry()'
    via: 'function call replacing DB query'
  - from: 'src/routes/api/sessions/[id]/merge/+server.ts:parseAndMatchLaps()'
    to: 'src/lib/server/telemetry/parquet.ts:readSessionTelemetry()'
    via: 'function call replacing DB query'
  - from: 'Parquet file on disk'
    to: 'SvelteKit page data'
    via: 'Parquet read + transform to existing data format'
```

---

## Objective

Migrate all telemetry read paths from PostgreSQL array columns to Parquet files. Update the session detail page, GPS API, path API, and merge API to read telemetry data from the new Parquet storage while maintaining the same data interface for the frontend.

---

## Task 1: Extend Parquet Module with Read Functions

**Type:** auto

**Files:** `src/lib/server/telemetry/parquet.ts`

**Action:**
Add read functions to the Parquet module to support all query patterns used by the application. The existing `readSessionTelemetry()` needs to be enhanced, and new specialized read functions need to be added.

**New/Enhanced Functions:**

```typescript
// Read full session (already partially implemented in 05-01)
// Enhance to support selective column reading for efficiency
export async function readSessionTelemetry(
	sessionId: number,
	options?: {
		columns?: string[]; // Select specific columns (null = all)
		lapNumbers?: number[]; // Filter to specific laps (null = all)
	}
): Promise<SessionTelemetry | null>;

// Read single lap with all channels (for lap analysis)
export async function readLapTelemetry(
	sessionId: number,
	lapNumber: number
): Promise<LapTelemetry | null>;

// Read specific columns for specific lap (for GPS/path APIs)
export async function readLapColumns(
	sessionId: number,
	lapNumber: number,
	columns: string[]
): Promise<Record<string, number[]> | null>;

// Read all laps but only specific columns (for chart data)
export async function readSessionColumns(
	sessionId: number,
	columns: string[]
): Promise<Array<{ lapNumber: number; data: Record<string, number[]> }>>;

// Get list of available channels in a session
export async function getSessionChannels(sessionId: number): Promise<string[]>;
```

**Implementation Details:**

1. Use Apache Arrow's column projection to read only needed columns (optimization)
2. Return data in the same format as the current DB queries to minimize frontend changes
3. Handle missing files gracefully (return null or empty arrays)
4. Transform columnar Parquet data back to the array format expected by existing code

**Parquet Read Pattern:**

```typescript
// Example implementation approach
import { parquetRead } from 'apache-arrow';

async function readSessionTelemetry(sessionId: number) {
  const filePath = getTelemetryPath(sessionId);

  if (!fs.existsSync(filePath)) {
    return null;
  }

  const table = await parquetRead(filePath);

  // Extract columns from Arrow table
  const lapNumbers = table.getChild('lap_number')?.toArray() || [];
  const time = table.getChild('time')?.toArray() || [];
  const speed = table.getChild('speed')?.toArray() || [];
  // ... extract other channels

  // Reconstruct SessionTelemetry structure
  return reconstructFromColumns(lapNumbers, time, speed, ...);
}
```

**Verify:**

```bash
# Check TypeScript compiles
npx tsc --noEmit src/lib/server/telemetry/parquet.ts 2>&1 | head -10
```

**Done:**

- [ ] All read functions implemented
- [ ] Functions handle missing files gracefully (return null)
- [ ] Column projection supported for efficient reads
- [ ] Data returned in format compatible with existing code

---

## Task 2: Update Session Detail Page (Page Server)

**Type:** auto

**Files:** `src/routes/sessions/[id]/+page.server.ts`

**Action:**
Replace the `lap_telemetry` and `telemetry_channels` database queries with Parquet file reads. Maintain the same return structure so the Svelte page component doesn't need changes.

**Current Code (to be replaced):**

```typescript
// Lines 44-51 currently read from DB:
const telemetryData = await db
	.select()
	.from(lap_telemetry)
	.where(eq(lap_telemetry.sessionId, sessionId));
const auxChannels =
	lapIds.length > 0
		? await db.select().from(telemetry_channels).where(inArray(telemetry_channels.lapId, lapIds))
		: [];
```

**New Code Structure:**

```typescript
import { readSessionTelemetry } from '$lib/server/telemetry/parquet';

// In load function:
const sessionTelemetry = await readSessionTelemetry(sessionId);

// Transform Parquet data to match existing structure
const lapsWithTelemetry = sessionLaps.map((l) => {
	const lapData = sessionTelemetry?.laps.find((tl) => tl.lapNumber === l.lapNumber);

	let cleanData: Record<string, number[]> | null = null;
	if (lapData && lapData.points.length > 0) {
		// Convert points array back to columnar arrays (expected by frontend)
		cleanData = {
			time: lapData.points.map((p) => p.time),
			distance: lapData.points.map((p) => p.distance).filter((v) => v !== undefined),
			speed: lapData.points.map((p) => p.speed).filter((v) => v !== undefined),
			lat: lapData.points.map((p) => p.lat).filter((v) => v !== undefined),
			long: lapData.points.map((p) => p.long).filter((v) => v !== undefined),
			rpm: lapData.points.map((p) => p.rpm).filter((v) => v !== undefined),
			throttle: lapData.points.map((p) => p.throttle).filter((v) => v !== undefined),
			brake: lapData.points.map((p) => p.brake).filter((v) => v !== undefined),
			gear: lapData.points.map((p) => p.gear).filter((v) => v !== undefined),
			steering: lapData.points.map((p) => p.steering).filter((v) => v !== undefined)
		};

		// Add auxiliary channels
		if (sessionTelemetry?.auxiliaryChannels) {
			for (const ch of sessionTelemetry.auxiliaryChannels) {
				const channelData = lapData.points.map((p) => p[ch]).filter((v) => v !== undefined);
				if (channelData.length > 0) {
					cleanData[ch] = channelData;
				}
			}
		}
	}

	return {
		...l,
		telemetryData: cleanData
	};
});
```

**Verify:**

```bash
# Check TypeScript compiles
npx tsc --noEmit src/routes/sessions/[id]/+page.server.ts 2>&1 | head -10
```

**Done:**

- [ ] Page server imports telemetry from Parquet instead of DB
- [ ] Data transformation produces same structure as before
- [ ] Auxiliary channels included in the response
- [ ] Handles missing Parquet files (empty telemetryData)

---

## Task 3: Update GPS API Endpoint

**Type:** auto

**Files:** `src/routes/api/sessions/[id]/gps/+server.ts`

**Action:**
Replace the database query with a targeted Parquet read that extracts only lat/long columns for the best lap.

**Current Code (to be replaced):**

```typescript
const telemetryRecord = await db
	.select({
		lat: lap_telemetry.lat,
		long: lap_telemetry.long
	})
	.from(lap_telemetry)
	.where(
		and(eq(lap_telemetry.sessionId, sessionId), eq(lap_telemetry.lapNumber, bestLap.lapNumber))
	);
```

**New Code Structure:**

```typescript
import { readLapColumns } from '$lib/server/telemetry/parquet';

// In GET handler:
const columns = await readLapColumns(sessionId, bestLap.lapNumber, ['lat', 'long']);

if (!columns || !columns.lat) {
	return json({ error: 'No GPS data found' }, { status: 404 });
}

return json({
	lat: columns.lat,
	long: columns.long
});
```

**Verify:**

```bash
npx tsc --noEmit src/routes/api/sessions/[id]/gps/+server.ts 2>&1 | head -10
```

**Done:**

- [ ] GPS API reads from Parquet instead of DB
- [ ] Returns same JSON structure { lat: number[], long: number[] }
- [ ] Handles missing data with 404 response

---

## Task 4: Update Path API Endpoint

**Type:** auto

**Files:** `src/routes/api/sessions/[id]/path/+server.ts`

**Action:**
Replace the database query with a Parquet read that extracts lat/long for all laps, stitches them together, and downsamples.

**Current Code (to be replaced):**

```typescript
const t = await db
	.select({
		lapNumber: lap_telemetry.lapNumber,
		lat: lap_telemetry.lat,
		long: lap_telemetry.long
	})
	.from(lap_telemetry)
	.where(eq(lap_telemetry.sessionId, sessionId))
	.orderBy(asc(lap_telemetry.lapNumber));
```

**New Code Structure:**

```typescript
import { readSessionColumns } from '$lib/server/telemetry/parquet';

// In GET handler:
const lapData = await readSessionColumns(sessionId, ['lapNumber', 'lat', 'long']);

if (lapData.length === 0) {
	return json({ error: 'No data' }, { status: 404 });
}

// Stitch arrays together (same logic as current)
const fullLat: number[] = [];
const fullLong: number[] = [];

lapData.forEach((row) => {
	if (row.data.lat && row.data.long) {
		fullLat.push(...row.data.lat);
		fullLong.push(...row.data.long);
	}
});

// Downsample (same logic as current)
const step = 5;
const downLat = fullLat.filter((_, i) => i % step === 0);
const downLong = fullLong.filter((_, i) => i % step === 0);

return json({ lat: downLat, long: downLong });
```

**Verify:**

```bash
npx tsc --noEmit src/routes/api/sessions/[id]/path/+server.ts 2>&1 | head -10
```

**Done:**

- [ ] Path API reads from Parquet instead of DB
- [ ] Stitches all laps together in order
- [ ] Downsamples with same 1/5th logic
- [ ] Returns same JSON structure

---

## Task 5: Update Merge API Endpoint

**Type:** auto

**Files:** `src/routes/api/sessions/[id]/merge/+server.ts`

**Action:**
Replace the database query for primary laps with a Parquet read. The merge endpoint needs to read the primary session's telemetry for alignment purposes.

**Current Code (to be replaced):**

```typescript
const primaryLaps = await db.query.lap_telemetry.findMany({
	where: eq(lap_telemetry.sessionId, sessionId),
	orderBy: [asc(lap_telemetry.lapNumber)],
	columns: { lapNumber: true, time: true, speed: true, distance: true, id: true }
});
```

**New Code Structure:**

```typescript
import { readSessionTelemetry } from '$lib/server/telemetry/parquet';

// In parseAndMatchLaps function:
const primarySessionData = await readSessionTelemetry(sessionId);

if (!primarySessionData || primarySessionData.laps.length === 0) {
	throw new Error('Primary session has no telemetry to align against.');
}

// Transform to the structure expected by matchLapsByDuration
const primaryLaps = primarySessionData.laps.map((lap) => {
	const timeArray = lap.points.map((p) => p.time);
	const speedArray = lap.points.map((p) => p.speed || 0);
	const distanceArray = lap.points.map((p) => p.distance || 0);

	return {
		lapNumber: lap.lapNumber,
		time: timeArray,
		speed: speedArray.length > 0 ? speedArray : null,
		distance: distanceArray,
		id: lap.lapNumber // Using lapNumber as id for compatibility
	};
});
```

**Note:** The merge endpoint also needs to handle the case where a session might not have Parquet data yet (backward compatibility during migration).

**Verify:**

```bash
npx tsc --noEmit src/routes/api/sessions/[id]/merge/+server.ts 2>&1 | head -10
```

**Done:**

- [ ] Merge API reads primary session from Parquet instead of DB
- [ ] Data transformed to expected structure for `matchLapsByDuration`
- [ ] Handles missing Parquet files gracefully

---

## Checkpoint: Read Path Integration Test

**Type:** checkpoint:manual

**Action:**
After implementing all read path changes, verify that the system can read from Parquet files correctly.

**Test Steps:**

1. Use a test Parquet file created in 05-01
2. Verify each endpoint returns correct data:
   - Session detail page loads without errors
   - GPS API returns lat/long arrays
   - Path API returns stitched path data
   - Merge API can read primary telemetry
3. Compare output format with original DB-based responses

**Verify:**

```bash
# Run type check on all modified files
npx tsc --noEmit src/routes/sessions/[id]/+page.server.ts src/routes/api/sessions/[id]/gps/+server.ts src/routes/api/sessions/[id]/path/+server.ts src/routes/api/sessions/[id]/merge/+server.ts 2>&1 | head -20
```

**Done:**

- [ ] All read paths compile without TypeScript errors
- [ ] Manual verification that endpoints return expected data format

---

## Verification Criteria

1. **Type Safety**: All modified files compile without TypeScript errors
2. **Data Compatibility**: Returned data matches structure of DB-based queries
3. **Performance**: Read performance equivalent or better than DB queries
4. **Error Handling**: Missing files handled gracefully (empty data or 404)
5. **Integration**: All telemetry-consuming endpoints use Parquet

---

## Success Criteria

- [ ] Session detail page loads telemetry from Parquet files
- [ ] GPS API endpoint reads from Parquet
- [ ] Path API endpoint reads from Parquet
- [ ] Merge API endpoint reads primary session from Parquet
- [ ] All endpoints return data in the same format as before
- [ ] Read performance is equivalent or better than DB queries
