---
phase: 01-correlation-engine
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: ['src/lib/analysis/preprocessing.ts', 'src/lib/analysis/preprocessing.test.ts']
autonomous: true

must_haves:
  truths:
    - 'Signals can be resampled to common frequency'
    - 'Signals can be normalized (z-score) for cross-correlation'
    - 'Window functions reduce edge effects in correlation'
    - 'Signal dropouts can be detected and interpolated'
  artifacts:
    - path: 'src/lib/analysis/preprocessing.ts'
      provides: 'Signal preprocessing pipeline'
      exports:
        [
          'resampleToFrequency',
          'zScoreNormalize',
          'applyHanningWindow',
          'detectDropouts',
          'interpolateDropouts'
        ]
    - path: 'src/lib/analysis/preprocessing.test.ts'
      provides: 'Unit tests for preprocessing'
      min_tests: 6
  key_links:
    - from: 'preprocessing.ts'
      to: 'correlation.ts'
      via: 'import and use'
      pattern: 'zScoreNormalize|resampleToFrequency'
---

<objective>
Implement signal preprocessing pipeline for telemetry data: resampling, normalization, windowing, and dropout handling.

Purpose: Clean, consistent preprocessing is essential for reliable cross-correlation. Different data loggers (VBOX 10Hz, Bosch 100Hz) need harmonization before correlation.
Output: preprocessing.ts module with comprehensive preprocessing functions and tests.
</objective>

<execution_context>
@/Users/kevingeorge/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/kevingeorge/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@/Users/kevingeorge/Documents/projects/flyinglizards/src/lib/analysis/correlation.ts
@/Users/kevingeorge/Documents/projects/flyinglizards/src/lib/server/merge.ts

# Existing resampleData in merge.ts handles basic interpolation

# Need: z-score normalization, windowing, dropout detection for robust correlation

# VBOX typically 10Hz, Bosch typically 100Hz - must normalize to common rate

</context>

<tasks>

<task type="auto">
  <name>Task 1: Resampling and normalization functions</name>
  <files>src/lib/analysis/preprocessing.ts</files>
  <action>
    Create preprocessing.ts with core signal processing functions:
    
    1. resampleToFrequency(signal, time, targetHz): Resample signal to target frequency
       - Generate new time array at targetHz from min(time) to max(time)
       - Use linear interpolation (reuse logic from merge.ts resampleData if suitable)
       - Return { signal: number[], time: number[] }
    
    2. zScoreNormalize(signal): Normalize to zero mean, unit variance
       - Calculate mean: sum(signal) / length
       - Calculate std: sqrt(sum((x - mean)^2) / (length - 1))
       - Handle edge case: if std == 0, return array of zeros
       - Return (x - mean) / std for each element
    
    3. applyHanningWindow(signal): Apply Hanning window to reduce edge effects
       - Hanning formula: w[n] = 0.5 - 0.5 * cos(2 * PI * n / (N - 1))
       - Multiply each signal[n] by w[n]
       - Return windowed signal
    
    Use Float64Array for performance. Export all functions.
    Add JSDoc comments explaining purpose and parameters.
  </action>
  <verify>npm run check -- --filter preprocessing.ts</verify>
  <done>preprocessing.ts exists with 3 exported functions, type-checks clean</done>
</task>

<task type="auto">
  <name>Task 2: Dropout detection and interpolation</name>
  <files>src/lib/analysis/preprocessing.ts, src/lib/analysis/preprocessing.test.ts</files>
  <action>
    Add dropout handling functions to preprocessing.ts:
    
    4. detectDropouts(signal, options?): Identify signal dropouts/gaps
       - Options: { threshold?: number, minLength?: number }
       - Default threshold: signal doesn't change for 3+ consecutive samples
       - Default minLength: 3 samples
       - Return array of { start: number, end: number, length: number } indices
       - Use derivative detection: consecutive values within epsilon of each other
    
    5. interpolateDropouts(signal, dropouts): Fill gaps using linear interpolation
       - For each dropout region, interpolate between value before start and value after end
       - If dropout at start/end of signal, use nearest valid value
       - Return new signal array with interpolated values
    
    Create preprocessing.test.ts with unit tests:
    - Test resampleToFrequency: verify correct interpolation at new time points
    - Test zScoreNormalize: verify mean ≈ 0, std ≈ 1 after normalization
    - Test applyHanningWindow: verify edges attenuated, center preserved
    - Test detectDropouts: correctly identifies flat regions as dropouts
    - Test interpolateDropouts: correctly fills gaps with interpolated values
    - Test combined pipeline: resample → normalize → window produces expected output
    
    Run all tests with `npm test src/lib/analysis/preprocessing.test.ts`
  </action>
  <verify>npm test src/lib/analysis/preprocessing.test.ts 2>&1 | grep -c "passed\|✓"</verify>
  <done>All preprocessing functions implemented, 6+ tests pass, coverage for all major functions</done>
</task>

<task type="auto">
  <name>Task 3: Integrate preprocessing with correlation</name>
  <files>src/lib/analysis/correlation.ts</files>
  <action>
    Update correlation.ts to use preprocessing pipeline:
    
    1. Import preprocessing functions:
       import { resampleToFrequency, zScoreNormalize, applyHanningWindow } from './preprocessing'
    
    2. Modify crossCorrelate to use preprocessing:
       - Step 1: Detect sample rates from time arrays (calculate from time differences)
       - Step 2: If different rates, resample both to common rate (10Hz default)
       - Step 3: Z-score normalize both signals
       - Step 4: Apply Hanning window to both signals
       - Step 5: Proceed with cross-correlation on preprocessed signals
    
    3. Add optional preprocessing flag (default true):
       interface CrossCorrelationOptions {
         maxOffsetSeconds?: number;
         targetSampleRate?: number;
         applyWindow?: boolean;  // default true
         normalize?: boolean;    // default true
       }
    
    4. Verify tests still pass with preprocessing integrated
       - Run correlation tests to ensure no regressions
       - If any failures, debug and fix
    
    5. Update CorrelationResult to include preprocessing info:
       interface CorrelationResult {
         offset: number;
         confidence: number;
         lag: number;
         sampleRate: number;      // Common sample rate used
         overlapRatio: number;    // Fraction of signals that overlapped
       }
  </action>
  <verify>npm test src/lib/analysis/correlation.test.ts && npm test src/lib/analysis/preprocessing.test.ts</verify>
  <done>Correlation uses preprocessing, all tests pass, CorrelationResult extended with metadata</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Run `npm test src/lib/analysis/preprocessing.test.ts` - all tests pass
2. Run `npm test src/lib/analysis/correlation.test.ts` - all tests pass (integration)
3. Run `npm run check` - no TypeScript errors
4. Verify preprocessing exports: resampleToFrequency, zScoreNormalize, applyHanningWindow, detectDropouts, interpolateDropouts
</verification>

<success_criteria>

- preprocessing.ts exists with 5 exported functions
- All preprocessing functions have unit tests (6+ tests)
- Tests pass for resampling, normalization, windowing, dropout handling
- correlation.ts uses preprocessing pipeline
- CorrelationResult includes sampleRate and overlapRatio
- Type checking passes
  </success_criteria>

<output>
After completion, create `.planning/phases/01-correlation-engine/01-02-SUMMARY.md`
</output>
